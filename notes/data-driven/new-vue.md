# new Vue发生了什么
## 初始化data
1. 调取_init方法进行初始化，在初始化data之前，先初始化props，然后初始化methods，然后才初始化data。
2. 根据判断data的类型为对象还是function做不同的处理。如果是data是function则获取它的返回值，同时判断返回值是否为对象，如果不是对象则抛错，如果data是对象，则获取data。遍历data的key值，与props和methods的属性名和方法名相同就抛错。
3. 用proxy代理函数，将data的每一个key都设置为可枚举属性，描述符配置为可修改，添加getter和setter方法，通过this[key]访问时，就相当于通过getter访问用this._data[key]访问。
## $mount(Vue实例挂载的实现)
$mount对于runtime+compiler版本会在entry-runtime-with-compiler中重新定义，而对于runtime only版本在runtime/index.js中
1. 在compiler版本中的$mount，先暂存一个runtime only版本的$mount作为基类，
2. 然后重新定义一个$mount，对el做处理，判断this.$options中是否具有render方法，如果没有，再判断是否有template属性，如果有template且template为"#id"形式，就调用idToTemplate方法，创建去创建或获取该id的dom节点，如果template为标签，则出去他的innerHTML，如果template如果既不是string也不是标签，则会报错。如果有el则获取整个el的dom，然后进行编译。
3. 调用基类的mount(runtime/index.js)中的$mount方法，该方法其实是调用mountComponent方法(来自instance/lifecycle.js中)，该方法会判断options上是否有render属性，没有就会创建一个空的虚拟节点作为render，在开发环境中，如果定义了template，并且template的第一个值不是#，或者定义了el，或者mountComponent中传入了Element类型的el，则抛出警告。后面定义了一个updateComponent，通过是否配置performance来判断是否需要性能埋点。然后执行vm._update(vm._render(), hydrating)【此处hydrating为是否是服务端渲染】。
4. 用一个渲染Wather来执行updateComponent，即new Watcher一个实例，然后在this.get()实际就是updateComponent方法中执行渲染，渲染得到的值通过判断是否为lazy模式，传递给this.value。这个过程除了首次触发，在视图发生变化是，也会通过updateComponent执行update，然后触发渲染Watcher，再次渲染。
## render
* 在init时，会执行initRender方法，会执行一个createElement方法来构造vnode，options中的render方法，实际上就是获取其中createElement方法，用于构造vnode。
* 通过执行_render()方法，而_render()方法将options中的render函数取出执行赋值给vnode，然后判断vnode是否是长度为等于1的数组，如果等于1就取出其中的第一个节点，如果vnode不是继承自VNode，那么如果在开发环境中且vnode为数组就抛错，否则就创建一个虚拟dom，最后将_parentVnode赋值给vnode.parent，再返回vnode
## Virtual DOM
```
let div = document.createElement('div')
let str = ''
for (item in div) {
    str += `${item} `
}
console.info(str)
// 上述将一个真实的dom节点打印如下
/*
align title lang translate dir hidden accessKey draggable spellcheck autocapitalize contentEditable isContentEditable inputMode offsetParent offsetTop offsetLeft offsetWidth offsetHeight style innerText outerText onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended onerror onfocus onformdata oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange onreset onresize onscroll onseeked onseeking onselect onstalled onsubmit onsuspend ontimeupdate ontoggle onvolumechange onwaiting onwebkitanimationend onwebkitanimationiteration onwebkitanimationstart onwebkittransitionend onwheel onauxclick ongotpointercapture onlostpointercapture onpointerdown onpointermove onpointerup onpointercancel onpointerover onpointerout onpointerenter onpointerleave onselectstart onselectionchange onanimationend onanimationiteration onanimationstart ontransitionrun ontransitionstart ontransitionend ontransitioncancel oncopy oncut onpaste dataset nonce autofocus tabIndex attachInternals blur click focus onpointerrawupdate enterKeyHint namespaceURI prefix localName tagName id className classList slot attributes shadowRoot part assignedSlot innerHTML outerHTML scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight attributeStyleMap onbeforecopy onbeforecut onbeforepaste onsearch elementTiming onfullscreenchange onfullscreenerror onwebkitfullscreenchange onwebkitfullscreenerror onbeforexrselect children firstElementChild lastElementChild childElementCount previousElementSibling nextElementSibling after animate append attachShadow before closest computedStyleMap getAttribute getAttributeNS getAttributeNames getAttributeNode getAttributeNodeNS getBoundingClientRect getClientRects getElementsByClassName getElementsByTagName getElementsByTagNameNS hasAttribute hasAttributeNS hasAttributes hasPointerCapture insertAdjacentElement insertAdjacentHTML insertAdjacentText matches prepend querySelector querySelectorAll releasePointerCapture remove removeAttribute removeAttributeNS removeAttributeNode replaceWith requestFullscreen requestPointerLock scroll scrollBy scrollIntoView scrollIntoViewIfNeeded scrollTo setAttribute setAttributeNS setAttributeNode setAttributeNodeNS setPointerCapture toggleAttribute webkitMatchesSelector webkitRequestFullScreen webkitRequestFullscreen ariaAtomic ariaAutoComplete ariaBusy ariaChecked ariaColCount ariaColIndex ariaColSpan ariaCurrent ariaDescription ariaDisabled ariaExpanded ariaHasPopup ariaHidden ariaKeyShortcuts ariaLabel ariaLevel ariaLive ariaModal ariaMultiLine ariaMultiSelectable ariaOrientation ariaPlaceholder ariaPosInSet ariaPressed ariaReadOnly ariaRelevant ariaRequired ariaRoleDescription ariaRowCount ariaRowIndex ariaRowSpan ariaSelected ariaSetSize ariaSort ariaValueMax ariaValueMin ariaValueNow ariaValueText getAnimations replaceChildren nodeType nodeName baseURI isConnected ownerDocument parentNode parentElement childNodes firstChild lastChild previousSibling nextSibling nodeValue textContent ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE DOCUMENT_POSITION_DISCONNECTED DOCUMENT_POSITION_PRECEDING DOCUMENT_POSITION_FOLLOWING DOCUMENT_POSITION_CONTAINS DOCUMENT_POSITION_CONTAINED_BY DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC appendChild cloneNode compareDocumentPosition contains getRootNode hasChildNodes insertBefore isDefaultNamespace isEqualNode isSameNode lookupNamespaceURI lookupPrefix normalize removeChild replaceChild addEventListener dispatchEvent removeEventListener 
*/
```
* 可以看到真实的dom是一个很庞大元素，由于浏览器的标准将DOM设计的非常复杂，当我们频繁的去更新DOM时就会产生很大性能问题
* Virtual DOM用一个原生的JS对象描述一个DOM节点，这样就减小了操作DOM时的性能开销，而在vue.js中是通过一个class来描述VNode，其中借鉴了一个snabbdom的开源库来实现，然后加入了vue特色的东西。
* VNode是对真实DOM的一种抽象描述，他的核心定义就是几个关键属性，标签名、数据、子节点、键值等，其他属性都是用来扩展VNode的灵活性以及实现一些特殊的feature的。由于VNode只是用来映射到真实DOM的渲染，不需要包含操作DOM，因此就非常轻量和简单。
* Virtual DOM除了他的数据结构的定义，映射到真实DOM实际上要经历VNode的create、diff、patch等过程。在vue.js中，VNode的create是通过createElement方法创建的。

